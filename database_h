#!/bin/bash
# file: database_h
# author: min chen(minchen@ubuntukylin.com) 2014 2015

my_dir=$(dirname "$0")

. $my_dir/common_h
. $my_dir/metadata_h
. $my_dir/epoch_h

db_image_prefix=
db_image_size=
db_order=
found=0

#init osd_data and get all objects path
function gen_database()
{
  local func="gen_database"
  rm -rf $database/*
  mkdir -p $database
  #for host in `cat $osd_host`
  local host=
  local data_path=
  while read line
  do
    {
      host=`echo $line|awk '{print $1}'`
      data_path=`echo $line|awk '{print $2}'`
      if [ "$host"x = ""x ] || [ "$data_path"x = ""x ];then
 	continue
      fi
      local cmds="find $data_path/current -type f"
      ssh $ssh_option $host $cmds > $database/$host
    } &
  done < $osd_host_path
  wait
  echo "$func: finish"
}

# collect hobjects from database 
# and choose the object whose epoch is lateset
# then, sort the objects by their offsets in image 
function gather_hobject_nosnap()
{
  func="gather_hobject_nosnap"
  if [ "$1"x = ""x ];then
    echo "$func: image_prefix not input"  
    exit
  fi

  local image_prefix=$1
  local underline_image_prefix=`convert_underline $1`
  local dump_image_prefix=`dump_backslash $underline_image_prefix`
  local images_raw=$images/raw
  local image_hobjects_raw=$images_raw/$image_prefix
  local image_hobjects_stable=$images/$image_prefix

  mkdir -p $images_raw

  pushd $database >/dev/null
  grep -r -E $dump_image_prefix".*__head_.*" * >$image_hobjects_raw
  if [ "`cat $image_hobjects_raw`"x = ""x ];then
    echo "$func: image[$image_prefix] is empty"
    exit
  fi
  popd >/dev/null

  if [ ! -e $image_hobjects_raw ];then
    echo "$func: image is empty"
    exit
  fi

  local offset_dir_temp=$images_raw/$image_prefix"_dir_temp"
  rm -rf $offset_dir_temp
  mkdir -p $offset_dir_temp

  echo "$func ..."

  # format: ceph2:/var/lib/ceph/osd/ceph-1/current/2.d3_head/rb.0.1293.6b8b4567.000000000002__head_FB425CD3__2
  local tmp_image=$offset_dir_temp/tmpimage
  >$tmp_image
  cat $image_hobjects_raw | 
  awk -F ':' '
  BEGIN {
    pg_coll="'$pg_coll'"
    tmp_image="'$tmp_image'"
    osd_host_mapping="'$osd_host_mapping'"
  }{ 
      # $2 = /var/lib/ceph/osd/ceph-1/current/2.d3_head/rb.0.1293.6b8b4567.000000000002__head_FB425CD3__2

      split($2, arr1, "/current/");   # {/var/lib/ceph/osd/ceph-1/, 2.d3_head/rb.0.1293.6b8b4567.000000000002__head_FB425CD3__2}
      split(arr1[2], arr2, "/");     # {2.d3_head, rb.0.1293.6b8b4567.000000000002__head_FB425CD3__2} 
      split(arr2[1], arr3, "_head"); # {2.d3,} 

      hobject=$2;
      data_path=arr1[1];
#      print data_path
      gsub(/\\u/, "\\\\\\\\\\\\\\\\u", hobject); # dump backslash to delay escape (\ -> \\)
      "awk \"\\$1 == \\\""$1"\\\" {print \\$2}\" "osd_host_mapping" | head -n 1" | getline node
      #print "node="node
      pgid = arr3[1];

      len=length(arr2);
      offset_hobject=arr2[len]             # rb.0.1293.6b8b4567.000000000002__head_FB425CD3__2
      split(offset_hobject, offarr1, "."); # {rb, 0, 1293, 6b8b4567, 000000000002__head_FB425CD3__2}
      len1=length(offarr1) 
      offset_p=offarr1[len1]               # 000000000002__head_FB425CD3__2
      split(offset_p, offarr2, "__");      # {000000000002, head_FB425CD3, 2}
      offset=offarr2[1];                   # 000000000002

      system("echo -n \""node" "pgid" "hobject" "offset" \" >>"tmp_image);
      #system("echo -n \""node" "pgid" "hobject" "offset" \"");
      
      # find pg_epoch from pg_coll database
      system("awk  \"\\$1 == \\\""node"\\\" && \\$2 == \\\""pgid"\\\" && \\$4 == \\\""data_path"\\\" {print \\$3}\" "pg_coll" >>"tmp_image);
      #system("awk  \"\\$1 == \\\""node"\\\" && \\$2 == \\\""pgid"\\\" && \\$4 == \\\""data_path"\\\" {print \\$3}\" "pg_coll);
  }'

  local sort_image=$offset_dir_temp/sortimage
  >$sort_image
  sort -t ' ' -k 4.1,4 -k 5.1nr -k 1.1,1 $tmp_image >$sort_image
  sort -t ' ' -k 4.1,4 -u $sort_image > $image_hobjects_stable
  
  #rm -rf $offset_dir_temp
}

# select the max pg_epoch item of the same $field
# if no same $field, choose the first 
# format : "node $field pg_epoch"
function choose_epoch()
{
  cat $1|sort -t ' ' -k 3.1,3nr -k 2.1,2n |head -n 1;
}

# lookup image info , after scatter_node_jobs & gather_node_infos
function lookup_image()
{
  local func="lookup_image"
  if [ "$1"x = ""x ];then
    echo "$func: no image name input"
    exit
  fi
  input_image $1
  local node=
  local item=/tmp/item.$$$$
  local image_metadata=$images_meta/$image_name_in
  local img_name=`dump_backslash $image_name`

  local image_format=0
  local image_id_hobject=
  local image_header_hobject=
  local result=/tmp/tmp_result.$$$$
  local res1=/tmp/tmp_res1.$$$$
  local res2=/tmp/tmp_res2.$$$$
  local data_path=

  # image format v1
  {
    cat $image_coll_v1|grep -E "/$img_name\.rbd__" >$res1
    if [ -s $res1 ];then
      echo -n "$func: rbd_header_hobject = "
      choose_epoch $res1| tee $item
      #choose_epoch $res1 > $item
      
      if [ -e $item ];then
        node=`cat $item|awk '{print $1}'`
        image_header_hobject=`cat $item|awk '{print $2}'`
        if [ "$node"x = ""x ];then
    	  echo "$func: v1 node is NULL"
 	  exit
	fi
	if [ "$image_header_hobject"x = ""x ];then
	  echo "$func: v1 image_header_hobject is NULL"
	  exit
  	fi
        rm -f $item
      fi
      
      #check_osd_process $node

      image_format=1
      echo -e "image_name:\t$image_name_in"
      echo -e "image_format:\t$image_format"
      data_path=`echo $image_header_hobject|awk -F "/current" '{print $1}'`
 
      >$result
      cmds="bash $job_path/osd_job do_image_metadata_v1 $data_path `dump_backslash $image_header_hobject`" 
      ssh $ssh_option $node $cmds | tee $result
    fi
  }

  # image format v2
  {
    cat $image_coll_v2|grep -E "/rbd\\\\uid\."$img_name"__" >$res2
    if [ -s $res2 ];then
      echo -n "$func: rbd_id = "
      choose_epoch $res2 | tee $item
      #choose_epoch $res2 > $item
  
      cat $item|awk '{print $1}'

      if [ -e $item ];then
        node=`cat $item|awk '{print $1}'`
        image_id_hobject=`cat $item|awk '{print $2}'`
        if [ "$node"x = ""x ];then
    	  echo "$func: v2 node is NULL(to get image_id_hobject)"
 	  exit
	fi
	if [ "$image_id_hobject"x = ""x ];then
	  echo "$func: v2 image_id_hobject is NULL"
	  exit
  	fi
        rm -f $item
      fi

      check_osd_process $node
      image_format=2
      
      local tid=/tmp/image_id.$$$$
      data_path=`echo $image_id_hobject|awk -F "/current" '{print $1}'`
      >$tid
      cmds="bash $job_path/osd_job do_image_id $data_path `dump_backslash $image_id_hobject`" 
      ssh $ssh_option $node $cmds > $tid

      local image_id=`cat $tid`
      rm -f $tid

      #get image_header_hobject
      pushd $database >/dev/null
      local pattern="header."$image_id"__head"
      local tcoll=/tmp/tmp_image_head_coll.$$$$

      # hostname(by command hostname) in $pg_coll  maybe different from hostname in tcoll(input by user) 
      # t_host:        hostname read from config file ($tcoll)
      # t_host_remote: $(hostname) on osd node ($pg_coll)
      grep -r $pattern * >$tcoll
      popd >/dev/null

      local t_host=(`cat $tcoll|awk -F ":" '{print $1}'`)
      local t_pgid=(`cat $tcoll|awk -F ":" '{print $2}'|sed -n 's/.*\/\([0-9a-fA-F]\+\.[0-9a-fA-F]\+\)_head\/.*/\1/p'`)
      local t_hobject=(`cat $tcoll|awk -F ":" '{print $2}'`)
      local t_data_path=(`cat $tcoll|awk -F ":" '{split($2, arr, "/current/"); print arr[1];}'`)
      rm -f $tcoll
      declare -a t_host_remote

      #if there is no failed pg migration, number of t_host is replica num
      #usually 3, 4, 5 ...
      local t_hostname=/tmp/t_hostname.$$$$
      for ((i=0; i<${#t_host[*]}; i++))
      do
	ssh $ssh_option ${t_host[$i]} "hostname" >$t_hostname
	if [ $? != 0 ];then
	  echo "$func: ${t_host[$i]} get host_remote failed"
	  exit
	fi
        t_host_remote[$i]=`cat $t_hostname`	
      done
      rm -f $t_hostname


      local t_item=/tmp/tmp_item.$$$$
      local tmp_item=/tmp/tmp_tmp_item.$$$$
      
      >$tmp_item
      for ((i=0; i<${#t_host_remote[*]}; i++ ))
      do
	local node=${t_host_remote[$i]}
	local pgid=${t_pgid[$i]}
	awk '$1 == "'"$node"'" && $2 == "'"$pgid"'" {print}' $pg_coll >>$tmp_item
      done

      # t_item: <remote_hostname> <pgid> <epoch> <data_path>
      sort -u $tmp_item >$t_item
      rm -f $tmp_item

      local entry=`choose_epoch $t_item` #t_host_remote
      rm -f $t_item

      node=`echo $entry|awk '{print $1}'`
      data_path=`echo $entry|awk '{print $4}'`
      if [ "$node"x = ""x ];then
        echo "$func: v2 node is NULL (to get image_header_hobject)"
        exit
      fi

      for ((i=0; i<${#t_host_remote[*]}; i++))
      do
	if [ "${t_host_remote[$i]}"x = "$node"x ] && [ "${t_data_path[$i]}"x = "$data_path"x ];then
	  image_header_hobject=${t_hobject[$i]}
	  break
	fi
      done
      
      if [ "$image_id_hobject"x = ""x ];then
        echo "$func: v2 image_header_hobject is NULL"
        exit
      fi

      check_osd_process $node
     
      echo "$func: rbd_header_hobject = $image_header_hobject"
      echo -e "image_name:\t$image_name_in"
      echo -e "image_format:\t$image_format"

      #data_path=`echo $image_header_hobject|awk -F "/current" '{print $1}'`
      >$result
      cmds="bash $job_path/osd_job do_image_metadata_v2 $data_path $image_id `dump_backslash $image_header_hobject`" 
      ssh $ssh_option $node $cmds | tee $result
    fi
  }

  if [ ! -s $result ];then
    echo "$func: $image_name_in not exists" 
    exit
  fi
  
  # to assign value to global variable : image_prefix
  db_image_prefix=`cat $result|awk '/^(object_prefix|block_name):/{print $2}'`
  if [ "$db_image_prefix"x = ""x ];then
    echo "$func: image_prefix is NULL"
    exit
  fi

  db_image_size=`cat $result|awk '/^image_size:/{print $2}'`
  db_order=`cat $result|awk '/^order:/{print $2}'`
  found=1
  rm -f $result
}

function list_images()
{
   echo "================ v1: ================"
   sed -n 's/\(.*\)\/\(.*\)\.rbd__\(.*\)/\2/p' $image_coll_v1|sort -u|sed -e 's/\\u/_/g'
   #cat /var/rbd_image/image_coll_v2|head -n 1|awk '{print $2}'|awk -F "current" '{print $1"current/"}'|wc -c
   echo "================ v2: ================"
   sed -n 's/\(.*\)\/rbd\\uid.\(.*\)__\(head.*\)/\2/p' $image_coll_v2|sort -u|sed 's/\\u/_/g'
}

# -------------------

function discover_image_nosnap()
{
  local func="discover_image_nosnap"
  lookup_image $1 # assign $image_prefix
  #echo "$func: image_prefix=$db_image_prefix"
  gather_hobject_nosnap $db_image_prefix 
  local image_hobjects_nosnap_stable=$images/$db_image_prefix
  mv $image_hobjects_nosnap_stable $images/$image_name_in
}

# after discove_image_nosnap
# collect objects from osds one by one in sequence
function copy_image_nosnap_single_thread()
{
  local func="copy_image_nosnap_single_thread"
  if [ "$1"x = ""x ];then
    echo "$func: image_hobjects file not input" 
    exit
  fi
  local image_hobjects=$1
  local backup_dir=$default_backup_dir

  if [ "$2"x != ""x ];then
    backup_dir=$2
  fi 

  # make sure lookup_image first
  if [ $found = 0 ];then
    echo "$func: image not found, maybe forget to discover_image"
    exit
  fi
  mkdir -p $backup_dir

  local image_file=$backup_dir/$image_name_in
  >$image_file
  truncate -s $db_image_size $image_file 

  local count=$(($db_image_size >> $db_order))
  local start=`cat $image_hobjects|head -n 1|awk '{print $4}'`
  local end=`cat $image_hobjects|tail -n 1|awk '{print $4}'`
  local entry_count=`cat $image_hobjects|wc -l`

  local char_bits=$((`echo $start|wc -c` -1 ))
  local format="%0"$char_bits"x"
  
  local expect_start=`printf $format 0`
  local expect_end=`printf $format $(($count -1 ))`  

  echo -e "object_count\t$entry_count"
  echo -e "expect\t\t[$expect_start ~ $expect_end] count:$count"
  echo -e "range\t\t[$start ~ $end] count:$entry_count"

  local icount=0
  local istart=
  local iend=
  local percent=
  
  local unit=$((1<<$db_order))
  while read line
  do
  {
    icount=$(($icount+1))
    node=`echo $line|awk '{print $1}'` 
    hobject=`echo $line|awk '{print $3}'` 
    offset=`echo $line|awk '{print $4}'`
    off=$((16#$offset))
    if [ $icount = 1 ];then
      istart=$offset
    fi
    hobject=`dump_backslash $hobject`
    iend=$offset
    sshcmd="cat $hobject"
    ssh $ssh_option $node $sshcmd < /dev/null | dd of=$image_file bs=$unit seek=$off conv=notrunc 2>/dev/null
    percent=`echo "scale=3; 100*$icount/$entry_count"|bc`
    tput sc  #record current cursor
    echo -n -e "complete\t[$istart ~ $iend] $icount/$entry_count ==> "$percent"%"
    if [ $icount != $entry_count ];then
      tput rc # backport most recent cursor
    fi
  }
  done < $image_hobjects

  echo
  echo -n "size: "
  ls -lh $image_file|awk '{print  $5"\t"$9}'
  echo -n "du:   "
  du -h $image_file
}

function recover_image()
{
  discover_image_nosnap $1 #input image_name 
  local image_hobjects=$images/$image_name_in
  copy_image_nosnap_single_thread $image_hobjects $2
}
