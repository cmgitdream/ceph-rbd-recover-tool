#!/bin/bash
# file: database_h
# author: min chen(minchen@ubuntukylin.com) 2014 2015

my_dir=$(dirname "$0")

. $my_dir/common_h
. $my_dir/metadata_h
. $my_dir/epoch_h

db_image_prefix=
db_image_size=
db_order=
db_snap_id=
db_snap_image_size=
found=0

#init osd_data and get all objects path
function gen_database()
{
  local func="gen_database"
  rm -rf $database/*
  mkdir -p $database
  #for host in `cat $osd_host`
  local host=
  local data_path=
  while read line
  do
    {
      host=`echo $line|awk '{print $1}'`
      data_path=`echo $line|awk '{print $2}'`
      if [ "$host"x = ""x ] || [ "$data_path"x = ""x ];then
 	continue
      fi
      local cmds="find $data_path/current -type f"
      ssh $ssh_option $host $cmds > $database/$host
    } &
  done < $osd_host_path
  wait
  echo "$func: finish"
}

# collect hobjects from database 
# and choose the object whose epoch is lateset
# then, sort the objects by their offsets in image 
function gather_hobject_common()
{
  func="gather_hobject_common"
  if [ "$1"x = ""x ];then
    echo "$func: image_prefix not input"  
    exit
    #return 2 #not exist
  fi

  local image_prefix=$1
  local snap_id=
  local hex_snap_id="head"
  local psuffix=
  local fsuffix="_head"
  if [ $# = 2 ];then
    snap_id=$2
    hex_snap_id=`printf "%x" $2`
    psuffix="_"$snap_id
    fsuffix="_"$snap_id
  fi
  local underline_image_prefix=`convert_underline $1`
  local dump_image_prefix=`dump_backslash $underline_image_prefix`
  local images_raw_dir=$rbd_image/raw
  local image_hobjects_dir=$images/$image_prefix
  # $images/raw/$image_prefix"_head"
  local image_hobjects_raw=$images_raw_dir/$image_prefix"$fsuffix"
  # $images/$image_prefix/$image_prefix"_head"
  local image_hobjects_stable=$image_hobjects_dir/$image_prefix"$fsuffix"

  if [ ! -e $image_raw_dir ];then
    mkdir -p $images_raw_dir
  fi
  if [ ! -e $image_hobjects_dir ];then
    mkdir -p $image_hobjects_dir
  fi

  pushd $database >/dev/null
  local pattern=".*__"$hex_snap_id"_.*"
  >$image_hobjects_raw
  grep -r -E $dump_image_prefix""$pattern * >$image_hobjects_raw
  if [ "`cat $image_hobjects_raw`"x = ""x ];then
    echo "$func: image snap [ $image_prefix"$psuffix" ] is empty"
    return 61 #no data available
  fi
  popd >/dev/null

  local offset_dir_temp=$images_raw_dir/$image_prefix"$fsuffix""_dir_temp"
  rm -rf $offset_dir_temp
  mkdir -p $offset_dir_temp

  echo "gather hobjects from database ..."

  # format: ceph2:/var/lib/ceph/osd/ceph-1/current/2.d3_head/rb.0.1293.6b8b4567.000000000002__head_FB425CD3__2
  local tmp_image=$offset_dir_temp/tmpimage.$$$$
  >$tmp_image
  cat $image_hobjects_raw | 
  awk -F ':' '
  BEGIN {
    pg_coll="'$pg_coll'"
    tmp_image="'$tmp_image'"
    osd_host_mapping="'$osd_host_mapping'"
  }{ 
      # $2 = /var/lib/ceph/osd/ceph-1/current/2.d3_head/rb.0.1293.6b8b4567.000000000002__head_FB425CD3__2

      split($2, arr1, "/current/");   # {/var/lib/ceph/osd/ceph-1/, 2.d3_head/rb.0.1293.6b8b4567.000000000002__head_FB425CD3__2}
      split(arr1[2], arr2, "/");     # {2.d3_head, rb.0.1293.6b8b4567.000000000002__head_FB425CD3__2} 
      split(arr2[1], arr3, "_head"); # {2.d3,} 

      hobject=$2;
      data_path=arr1[1];
      gsub(/\\u/, "\\\\\\\\\\\\\\\\u", hobject); # dump backslash to delay escape (\ -> \\)
      "awk \"\\$1 == \\\""$1"\\\" {print \\$2}\" "osd_host_mapping" | head -n 1" | getline node
      pgid = arr3[1];

      len=length(arr2);
      offset_hobject=arr2[len]             # rb.0.1293.6b8b4567.000000000002__head_FB425CD3__2
      split(offset_hobject, offarr1, "."); # {rb, 0, 1293, 6b8b4567, 000000000002__head_FB425CD3__2}
      len1=length(offarr1) 
      offset_p=offarr1[len1]               # 000000000002__head_FB425CD3__2
      split(offset_p, offarr2, "__");      # {000000000002, head_FB425CD3, 2}
      offset=offarr2[1];                   # 000000000002

      system("echo -n \""node" "pgid" "hobject" "offset" \" >>"tmp_image);
      
      # find pg_epoch from pg_coll database
      system("awk  \"\\$1 == \\\""node"\\\" && \\$2 == \\\""pgid"\\\" && \\$4 == \\\""data_path"\\\" {print \\$3}\" "pg_coll" >>"tmp_image);
  }'

  local sort_image=$offset_dir_temp/sortimage.$$$$
  >$sort_image
  sort -t ' ' -k 4.1,4 -k 5.1nr -k 1.1,1 $tmp_image >$sort_image
  sort -t ' ' -k 4.1,4 -u $sort_image > $image_hobjects_stable
  
  #rm -rf $offset_dir_temp
  return 0
}

function gather_hobject_nosnap()
{
  gather_hobject_common $1
}

function gather_hobject_snap()
{
  gather_hobject_common $1 $2
}

# select the max pg_epoch item of the same $field
# if no same $field, choose the first 
# format : "node $field pg_epoch"
function choose_epoch()
{
  cat $1|sort -t ' ' -k 3.1,3nr -k 2.1,2n |head -n 1;
}

# lookup image info , after scatter_node_jobs & gather_node_infos
function lookup_image()
{
  local func="lookup_image"
  if [ "$1"x = ""x ];then
    echo "$func: no image name input"
    exit
  fi
  local snap_name=$2
  echo -e "$func: image_name=$image_name\tsnap_name=$snap_name"
  input_image $1
  local node=
  local item=/tmp/item.$$$$
  local image_metadata=$images_meta/$image_name_in
  local img_name=`dump_backslash $image_name`

  local image_format=0
  local image_id_hobject=
  local image_header_hobject=
  local result=/tmp/tmp_result.$$$$
  local res1=/tmp/tmp_res1.$$$$
  local res2=/tmp/tmp_res2.$$$$
  local data_path=

  # image format v1
  {
    cat $image_coll_v1|grep -E "/$img_name\.rbd__" >$res1
    if [ -s $res1 ];then
      echo -n "$func: rbd_header_hobject = "
      choose_epoch $res1| tee $item
      #choose_epoch $res1 > $item
      
      if [ -e $item ];then
        node=`cat $item|awk '{print $1}'`
        image_header_hobject=`cat $item|awk '{print $2}'`
        if [ "$node"x = ""x ];then
    	  echo "$func: v1 node is NULL"
 	  exit
	fi
	if [ "$image_header_hobject"x = ""x ];then
	  echo "$func: v1 image_header_hobject is NULL"
	  exit
  	fi
        rm -f $item
      fi

      image_format=1
      echo -e "image_name:\t$image_name_in"
      echo -e "image_format:\t$image_format"
      data_path=`echo $image_header_hobject|awk -F "/current" '{print $1}'`
 
      >$result
      cmds="bash $job_path/osd_job do_image_metadata_v1 $data_path `dump_backslash $image_header_hobject` $snap_name" 
      ssh $ssh_option $node $cmds | tee $result
    fi
  }

  # image format v2
  {
    cat $image_coll_v2|grep -E "/rbd\\\\uid\."$img_name"__" >$res2
    if [ -s $res2 ];then
      echo -n "$func: rbd_id_hobject = "
      choose_epoch $res2 | tee $item
      #choose_epoch $res2 > $item

      if [ -e $item ];then
        node=`cat $item|awk '{print $1}'`
        image_id_hobject=`cat $item|awk '{print $2}'`
        if [ "$node"x = ""x ];then
    	  echo "$func: v2 node is NULL(to get image_id_hobject)"
 	  exit
	fi
	if [ "$image_id_hobject"x = ""x ];then
	  echo "$func: v2 image_id_hobject is NULL"
	  exit
  	fi
        rm -f $item
      fi

      check_osd_process $node
      image_format=2
      
      local tid=/tmp/image_id.$$$$
      data_path=`echo $image_id_hobject|awk -F "/current" '{print $1}'`
      >$tid
      cmds="bash $job_path/osd_job do_image_id $data_path `dump_backslash $image_id_hobject`" 
      ssh $ssh_option $node $cmds > $tid

      local image_id=`cat $tid`
      rm -f $tid

      #get image_header_hobject
      pushd $database >/dev/null
      local pattern="header."$image_id"__head"
      local tcoll=/tmp/tmp_image_head_coll.$$$$

      # hostname(by command hostname) in $pg_coll  maybe different from hostname in tcoll(input by user) 
      # t_host:        hostname read from config file ($tcoll)
      # t_host_remote: $(hostname) on osd node ($pg_coll)
      grep -r $pattern * >$tcoll
      popd >/dev/null

      local t_host=(`cat $tcoll|awk -F ":" '{print $1}'`)
      local t_pgid=(`cat $tcoll|awk -F ":" '{print $2}'|sed -n 's/.*\/\([0-9a-fA-F]\+\.[0-9a-fA-F]\+\)_head\/.*/\1/p'`)
      local t_hobject=(`cat $tcoll|awk -F ":" '{print $2}'`)
      local t_data_path=(`cat $tcoll|awk -F ":" '{split($2, arr, "/current/"); print arr[1];}'`)
      rm -f $tcoll
      declare -a t_host_remote

      #if there is no failed pg migration, number of t_host is replica num
      #usually 3, 4, 5 ...
      local t_hostname=/tmp/t_hostname.$$$$
      for ((i=0; i<${#t_host[*]}; i++))
      do
	ssh $ssh_option ${t_host[$i]} "hostname" >$t_hostname
	if [ $? != 0 ];then
	  echo "$func: ${t_host[$i]} get host_remote failed"
	  exit
	fi
        t_host_remote[$i]=`cat $t_hostname`	
      done
      rm -f $t_hostname

      local t_item=/tmp/tmp_item.$$$$
      local tmp_item=/tmp/tmp_tmp_item.$$$$
      
      >$tmp_item
      for ((i=0; i<${#t_host_remote[*]}; i++ ))
      do
	local node=${t_host_remote[$i]}
	local pgid=${t_pgid[$i]}
	awk '$1 == "'"$node"'" && $2 == "'"$pgid"'" {print}' $pg_coll >>$tmp_item
      done

      # t_item: <remote_hostname> <pgid> <epoch> <data_path>
      sort -u $tmp_item >$t_item
      rm -f $tmp_item

      local entry=`choose_epoch $t_item` #t_host_remote
      rm -f $t_item

      node=`echo $entry|awk '{print $1}'`
      data_path=`echo $entry|awk '{print $4}'`
      if [ "$node"x = ""x ];then
        echo "$func: v2 node is NULL (to get image_header_hobject)"
        exit
      fi

      for ((i=0; i<${#t_host_remote[*]}; i++))
      do
	if [ "${t_host_remote[$i]}"x = "$node"x ] && [ "${t_data_path[$i]}"x = "$data_path"x ];then
	  image_header_hobject=${t_hobject[$i]}
	  break
	fi
      done
      
      if [ "$image_id_hobject"x = ""x ];then
        echo "$func: v2 image_header_hobject is NULL"
        exit
      fi

      check_osd_process $node
     
      echo "$func: rbd_header_hobject = $node $image_header_hobject"
      echo -e "image_name:\t$image_name_in"
      echo -e "image_format:\t$image_format"

      #data_path=`echo $image_header_hobject|awk -F "/current" '{print $1}'`
      >$result
      cmds="bash $job_path/osd_job do_image_metadata_v2 $data_path $image_id `dump_backslash $image_header_hobject` $snap_name" 
      ssh $ssh_option $node $cmds | tee $result
    fi
  }

  if [ ! -s $result ];then
    echo "$func: $image_name_in not exists" 
    exit
  fi
  
  # to assign value to global variable
  db_image_prefix=`cat $result|awk '/^(object_prefix|block_name):/{print $2}'`
  if [ "$db_image_prefix"x = ""x ];then
    echo "$func: image_prefix is NULL"
    exit
  fi

  db_image_size=`cat $result|awk '/^image_size:/{print $2}'`
  db_order=`cat $result|awk '/^order:/{print $2}'`
  if [ "$snap_name"x != ""x ];then
    db_snap_id=`cat $result|awk '/^snapshot:/{print $2}'`
    if [ "$db_snap_id"x = ""x ];then
      echo "$func: $image_name_in@$snap_name NOT EXISTS"
      exit
    fi
    db_snap_image_size=`cat $result|awk '/^snapshot:/{print $4}'`
  else
    #save snaplist
    local image_snaplist=$images/$image_name_in/@snaplist
    if [ ! -e $images/$image_name_in ];then
      mkdir -p $images/$image_name_in
    fi
    cat $result|awk '/^snapshot:/{print $2" "$3" "$4}' >$image_snaplist
  fi
  found=1
  rm -f $result
}

function list_images()
{
   echo "================ v1: ================"
   sed -n 's/\(.*\)\/\(.*\)\.rbd__\(.*\)/\2/p' $image_coll_v1|sort -u|sed -e 's/\\u/_/g'
   #cat /var/rbd_image/image_coll_v2|head -n 1|awk '{print $2}'|awk -F "current" '{print $1"current/"}'|wc -c
   echo "================ v2: ================"
   sed -n 's/\(.*\)\/rbd\\uid.\(.*\)__\(head.*\)/\2/p' $image_coll_v2|sort -u|sed 's/\\u/_/g'
}

# -------------------

function discover_image_nosnap()
{
  local func="discover_image_nosnap"
  lookup_image $1 # assign $image_prefix
  #echo "$func: image_prefix=$db_image_prefix"
  gather_hobject_nosnap $db_image_prefix 
  if [ $? -ne 0 ];then
    exit
  fi
  local image_hobjects_stable_nosnap=$images/$db_image_prefix/$db_image_prefix"_head"
  local image_hobjects_dir=$images/$image_name_in
  if [ ! -e $image_hobjects_dir ];then
    mkdir -p $image_hobjects_dir
  fi
  # mv image_prefix to image_name
  mv $image_hobjects_stable_nosnap $image_hobjects_dir/$image_name_in
  rm -rf $images/$db_image_prefix
}

function gen_object_snap_mapping()
{
  local func="gen_object_snap_mapping"
  if [ $# -lt 2 ];then
    echo "$func: parameters number error"
    exit
  fi
  local snapid=$1
  local snapset_dir=$2
   
 
}

function get_object_clone()
{
  local func="get_object_clone"
  if [ $# -lt 4 ];then
    echo "$func: parameters number error"
    exit
  fi

  local object_offset_string=$1
  local snapid=$2
  local snaplist_path=$3
  local snapset_output_dir=$4

  local snap_coll_arr=(`
  cat $snaplist_path|awk '{ if ($1 >= "'"$snapid"'") print "'"$snapset_output_dir"'/@"$1}'`) 

  local hex_snapid=`printf "%x" $snapid`
  pushd $snapset_output_dir >/dev/null
  # grep pattern need to fix
  #grep -r -E "data.*__"$hex_snapid"_"  `echo ${snap_coll_arr[@]}`
  echo $object_offset_string
  awk '/'"$object_offset_string"'/{print}' `echo ${snap_coll_arr[@]}`
  popd >/dev/null
}

function gen_snapset_hobject()
{
  local func="gen_image_snapset"
  if [ $# -lt 3 ];then
    echo "$func: parameter number error"
  fi
  local image_prefix=$1
  local snaplist_path=$2
  local snapset_output_dir=$3
  OIFS=$IFS
  IFS=$'\n'
  local snaparr=(`cat $snaplist_path`) 
  for line in ${snaparr[@]}
  do
    OOIFS=$IFS
    IFS=$' '
    local field=(`echo $line`)
    local snapid=${field[0]}
    local image_hobjects_stable_snap=$images/$image_prefix/$image_prefix"_"$snapid
    local image_snap=$snapset_output_dir/@$snapid
    gather_hobject_snap $image_prefix $snapid 
    if [ $? -ne 0 ];then
      touch $image_snap
    else 
      mv $image_hobjects_stable_snap $image_snap
    fi
    IFS=$OOIFS
  done
  IFS=$OIFS
}

function discover_image_snap()
{
  local func="discover_image_snap"
  echo "$func ..."

  local snap_name=$2
  #mkdir -p $images/$image_prefix
  lookup_image $1 $2 # input image_name and snap_name to lookup metadata and snap_id
  if [ "$db_snap_id"x = ""x ];then
    echo "$func: lookup image failed to gen snapid"
    exit
  fi
  local image_nosnap=$images/$image_name_in 
  #check if image nosnap recovered
  if [ ! -s $image_nosnap ];then
    echo "$func: please recover image nosnap before recover with snap"
    rm -rf $images/$db_image_prefix
    exit
  fi
  local image_hobject_dir=$images/$image_name_in
  local image_snap=$image_hobject_dir/@snap_$db_snap_id
  local image_snaplist=$image_hobject_dir/@snaplist
  local image_snapset_dir=$image_hobject_dir/@snapset_dir
  if [ ! -e $image_hobject_dir ];then
    mkdir -p $image_hobject_dir
  fi
  # only gen snapset one time
  if [ ! -e $image_snapset_dir ];then
    mkdir -p $image_snapset_dir
    gen_snapset_hobject $db_image_prefix $image_snaplist $image_snapset_dir  
  fi
  rm -rf $images/$db_image_prefix

  #get_object_clone 0 $db_snap_id $image_snaplist $image_snapset_dir
  #get_object_clone 1 $db_snap_id $image_snaplist $image_snapset_dir
  #get_object_clone 2 $db_snap_id $image_snaplist $image_snapset_dir
  get_object_clone "0000000000000003" $db_snap_id $image_snaplist $image_snapset_dir
}

# after discover_image_nosnap
# collect objects from osds one by one in sequence
function copy_image_nosnap_single_thread()
{
  local func="copy_image_nosnap_single_thread"
  if [ "$1"x = ""x ];then
    echo "$func: image_hobjects file not input" 
    exit
  fi
  local image_hobjects=$1
  local backup_dir=$default_backup_dir

  if [ "$2"x != ""x ];then
    backup_dir=$2
  fi 

  # make sure lookup_image first
  if [ $found = 0 ];then
    echo "$func: image not found, maybe forget to discover_image"
    exit
  fi
  if [ ! -e $backup_dir ];then
    mkdir -p $backup_dir
  fi

  local image_dir=$backup_dir/$image_name_in
  local image_file=$image_dir/$image_name_in
  local CURRENT=$image_dir/@CURRENT
  local LOCK=$image_dir/@LOCK
  if [ ! -e $image_dir ];then
    mkdir -p $image_dir
  fi
  if [ -e $LOCK ];then
    echo "$func: $LOCK is locked by other process"
    exit
  else
    touch $LOCK
  fi

  >$image_file
  truncate -s $db_image_size $image_file 
  echo "head">$CURRENT

  local count=$(($db_image_size >> $db_order))
  local start=`cat $image_hobjects|head -n 1|awk '{print $4}'`
  local end=`cat $image_hobjects|tail -n 1|awk '{print $4}'`
  local entry_count=`cat $image_hobjects|wc -l`

  local char_bits=$((`echo $start|wc -c` -1 ))
  local format="%0"$char_bits"x"
  
  local expect_start=`printf $format 0`
  local expect_end=`printf $format $(($count -1 ))`  

  echo -e "object_count\t$entry_count"
  echo -e "expect\t\t[$expect_start ~ $expect_end] count:$count"
  echo -e "range\t\t[$start ~ $end] count:$entry_count"

  local icount=0
  local istart=
  local iend=
  local percent=
  
  local unit=$((1<<$db_order))
  while read line
  do
  {
    icount=$(($icount+1))
    node=`echo $line|awk '{print $1}'` 
    hobject=`echo $line|awk '{print $3}'` 
    offset=`echo $line|awk '{print $4}'`
    off=$((16#$offset))
    if [ $icount = 1 ];then
      istart=$offset
    fi
    hobject=`dump_backslash $hobject`
    iend=$offset
    sshcmd="cat $hobject"
    ssh $ssh_option $node $sshcmd < /dev/null | dd of=$image_file bs=$unit seek=$off conv=notrunc 2>/dev/null
    percent=`echo "scale=3; 100*$icount/$entry_count"|bc`
    tput sc  #record current cursor
    echo -n -e "complete\t[$istart ~ $iend] $icount/$entry_count ==> "$percent"%"
    if [ $icount != $entry_count ];then
      tput rc # backport most recent cursor
    fi
  }
  done < $image_hobjects

  echo
  echo -n "size: "
  ls -lh $image_file|awk '{print  $5"\t"$9}'
  echo -n "du:   "
  du -h $image_file
  #unlock
  rm -f $LOCK
}


#ssh copy snap_object & head_object from osd to admin node
function collect_image_snap_objects()
{
  #$1=backup_dir, $2=snap_name, $3=snap_hobjects, $4=head_hobjects
  if [ $# -lt 5 ];then
    exit
  fi  
  echo "$1 $2 $3 $4 $5"

  local image_name=$1
  local snap_id=$2
  local snap_hobjects=$3
  local head_hobjects=$4
  local backup_dir=$5

  local head_dir=$backup_dir/$image_name/@head
  local snap_dir=$backup_dir/$image_name/@$snap_id
  local CURRENT=$backup_dir/$image_name/@CURRENT
 
  if [ ! -e $head_dir ];then
    mkdir -p $head_dir
  fi
  if [ ! -e $snap_dir ];then
    mkdir -p $snap_dir
  fi

  # snap_hobjects and head_hobjects are sorted
  local snap_node=
  local snap_hobject=
  local snap_offset=
  local snap_filename=
  local head_node=
  local head_hobject=
  local head_offset=
  local head_filename=

  local start=`head -n 1 $snap_hobjects|awk '{print $4}'`
  local end=`tail -n 1 $snap_hobjects|awk '{print $4}'`
  local entry_count=`cat $snap_hobjects|wc -l`
  if [ $((16#$first_offset)) -gt $((16#$last_offset)) ];then
    echo "$func: $snap_hobjects not sorted"
    exit
  fi


  local n1=`grep -n $start $head_hobjects|head -n 1|cut -d ":" -f 1`
  local n2=`grep -n $end $head_hobjects|head -n 1|cut -d ":" -f 1`
 
  local icount=0
  local istart=
  local iend=
  local percent=

  OIFS=$IFS
  IFS=$'\n'

  #assume file:snap_hobjects is not very large, and can be load into memory
  local snap_arr=(`cat $snap_hobjects`)
  local snap_tmp=/tmp/snaptmp.$$$$

  head -n $n2 $head_hobjects|tail -n $(($n2-$n1+1)) >$snap_tmp 

  echo "copy image snap objects form osd ..."
  echo -e "object_count\t$entry_count"
  echo -e "range\t\t[$start ~ $end] count:$entry_count"

  for line in ${snap_arr[*]}
  do
    icount=$(($icount+1))    

    OOIFS=$IFS
    IFS=$' '
    local arr=(`echo $line`)

    snap_node=${arr[0]}
    snap_hobject=${arr[2]}

    snap_offset=${arr[3]}
    if [ $icount = 1 ];then
      istart=$snap_offset
    fi
    iend=$snap_offset

    snap_filename=$snap_dir/$snap_offset
    local res=`grep $snap_offset $snap_tmp|head -n 1` 
    if [ "$res"x = ""x ];then
      echo "$func: image object[ $snap_offset ] missing"
      exit
    fi

    local arr2=(`echo $res`)
    head_node=${arr2[0]}
    head_hobject=${arr2[2]}
    head_offset=${arr2[3]}
    head_filename=$head_dir/$head_offset

 #   echo "$snap_node $snap_filename    $head_node $head_filename"
    #ssh $ssh_option $snap_node "cat $snap_hobject" > $snap_filename 
    #if [ ! -e $head_filename ];then
    #  ssh $ssh_option $head_node "cat $head_hobject" > $head_filename 
    #fi
    IFS=$OOIFS

    percent=`echo "scale=3; 100*$icount/$entry_count"|bc`
    tput sc  #record current cursor
    echo -n -e "complete\t[$istart ~ $iend] $icount/$entry_count ==> "$percent"%"
    if [ $icount != $entry_count ];then
      tput rc # backport most recent cursor
    fi
  done
  echo
  IFS=$OIFS 
}

function copy_image_snap_single_thread()
{
  local func="collect_image_snap_objects"
  #image_name_in, db_snap_id
  echo "num: $#"
  if [ $# -lt 4 ];then
    echo "$func: parameters number not correct" 
    exit
  fi
  local image_name=$1
  local snap_id=$2
  local snap_hobjects=$3
  local head_hobjects=$4
  local backup_dir=$default_backup_dir
  if [ "$5"x != ""x ];then
    backup_dir=$4
  fi

  local LOCK=$backup_dir/$image_name/@LOCK
  if [ -e $LOCK ];then
    echo "$func: $LOCK is locked by other process"
    exit
  else
    touch $LOCK
  fi
  collect_image_snap_objects $image_name $snap_id $snap_hobjects $head_hobjects $backup_dir
  #unlock
  rm -f $LOCK
}

function recover_image()
{
  #$1=image_name, $2=snap_name, $3=backup_dir
  local func="recover_image"
  local img_name=$1
  local snap_name=
  if [ "$2"x != "@"x ];then
    snap_name=$2
  fi
  local backup_dir=
  if [ "$3"x != ""x ];then
    backup_dir=$3
  fi
  echo "$func: $1 $2 $3"
  if [ "$snap_name"x = ""x ];then
  #recover with nosnap
    echo "func: discover_image_nosnap"
    discover_image_nosnap $img_name #input image_name 
    local image_hobjects=$images/$image_name_in/$image_name_in
    copy_image_nosnap_single_thread $image_hobjects $backup_dir
  else
  #recover with snap
    discover_image_snap $img_name $snap_name # get image meta
    #local snap_hobjects=$images/$image_name_in/@snap_$db_snap_id
    #local head_hobjects=$images/$image_name_in/$image_name_in
    
    #copy_image_snap_single_thread $image_name_in $db_snap_id $snap_hobjects $head_hobjects $backup_dir
  fi
}
