#!/bin/bash
# file: common_h
# author: min chen(minchen@ubuntukylin.com) 2014

my_dir=$(dirname "$0")

# admin node init path
rbd_image=/var/rbd_image
database=$rbd_image/database
image_coll_v1=$rbd_image/image_coll_v1
image_coll_v2=$rbd_image/image_coll_v2
pg_coll=$rbd_image/pg_coll
images=$rbd_image/images
images_meta=$rbd_image/images_meta
default_backup_dir=/var/default_backup_dir

# osd node init path
job_path=/var/osd_job
osd_env=$my_dir/osd_env

# osd node path vars
osd_data= #/var/lib/ceph/osd/$cluster-$id
omap_path= #$osd_data/current/omap
single_node=/var/single_node
image_v1= #$single_node/$cluster-$id/image_v1
image_v2= #$single_node/$cluster-$id/image_v2
node_pg_epoch= #$single_node/$cluster-$id/node_pg_epoch
omap_list= #$single_node/$cluster-$id/omap_list 

# admin node config file
osd_host_path=$my_dir/config/osd_host_path
osd_host=$my_dir/config/osd_host
mon_host=$my_dir/config/mon_host
mds_host=$my_dir/config/mds_host

# ssh option
ssh_option="-o ConnectTimeout=1"

# for osd node
function init_env_osd()
{
  local func="init_env_osd"
  if [ ! -e $single_node ];then
    mkdir -p $single_node
  fi
  # only after set_env_osd is called, osd_data & omap_path will be set
  if [ -s $osd_env ];then
      osd_data=`cat $osd_env|head -n 1|tr -d [:blank:]`
      omap_path=$osd_data/current/omap
      local cluster_id=`basename $osd_data`
      mkdir -p $single_node/$cluster_id
      image_v1=$single_node/$cluster_id/image_v1
      image_v2=$single_node/$cluster_id/image_v2
      node_pg_epoch=$single_node/$cluster_id/node_pg_epoch
      omap_list=$single_node/$cluster_id/omap_list
  fi
}

# for admin node
function init_env_admin()
{
  local func="init_env_admin" 
  if [ ! -s $osd_host_path ];then
    echo "$func: osd_host_path not exists or empty"
    exit
  fi
  if [ ! -e $rbd_image ];then
    mkdir -p $rbd_image
  fi
  if [ ! -e $images ];then
    mkdir -p $images
  fi
  if [ ! -e $images_meta ];then
    mkdir -p $images_meta
  fi

  if [ ! -s $mon_host ];then
    echo "$func: mon_host not exists or empty"
    exit
  fi
  if [ ! -e $mds_host ];then
    echo "$func: mds_host not exists"
    exit
  fi
  # we just tell if osd_host is filled
  if [ -s $osd_host ];then
    return  
  fi
  # create file: osd_host
  >$osd_host
  local lines=0
  local lineno=0
  while read line
  do
    lineno=$(($lineno + 1))
    if [ "$line"x = ""x ];then
      continue;
    fi
    local node=`echo $line|awk '{print $1}'`
    if [ "$node"x = ""x ];then
      echo "$func: osd_host_path : line $lineno: osd_host not input"
      exit
    fi
    local data_path=`echo $line|awk '{print $2}'`
    if [ "$data_path"x = ""x ];then
      echo "$func: osd_host_path : line $lineno: osd_data not input"
      exit
    fi
    lines=$(($lines + 1))
    echo $node >> $osd_host
  done < $osd_host_path

  if [ $lines = 0 ];then
    echo "$func: no osd host path valid"
    exit
  fi
}

# for osd node
function get_omap_list()
{
  ceph-kvstore-tool $omap_path list > $omap_list
}

function convert_underline()
{
  if [ "$1"x = ""x ];then
    return
  fi

  echo $1|sed -e 's/_/\\u/gp'|head -n 1
}

function dump_backslash()
{
  echo $*|sed -e 's/\\/\\\\/gp'|head -n 1
}

function dump_dump_backslash()
{
  echo $*|sed -e 's/\\/\\\\\\\\/gp'|head -n 1
}

function char_convert()
{
  if [ "$1"x = ""x ];then
    return
  fi

  echo $1|sed -e 's/_/\\u/gp' -e 's/\./%e/gp' -e 's/%/%p/gp'|head -n 1
}

function check_osd_process()
{
  local func="check_osd_process"
  local host=$1
  if [ "$1"x = ""x ];then
    exit
  fi
  local cmds="ps aux|grep ceph-osd|grep -v grep"
  local ret=/tmp/ret.$$$$
  ssh $ssh_option $host $cmds |tee $ret
  if [ -s $ret ];then
    echo "$func: [$host] ceph-osd process is not killed"
    exit
  fi
  rm -f $ret 
}

function get_map_header_prefix()
{
  echo "_HOBJTOSEQ_"
}

function get_map_header_key()
{
  local func="get_map_header_key"
  if [ "$1"x = ""x ];then
    #echo $func': no keyword input'
    exit 
  fi 
  local keyword=$1
  local res=`cat $omap_list| grep $keyword`
  if [ "$res"x = ""x ];then
    #echo "$func: map_header_key = $keyword not exisits"
    exit
  fi
  echo $res|awk -F ":" '{print $2}'
}

function get_header_seq() 
{
  local func="get_header_seq"
  if [ "$1"x == ""x ];then
    #echo "$func: no prefix input"
    exit;
  elif [ "$2"x == ""x ];then
    #echo "$func: no key input"
    exit;
  fi
  local prefix=$1;
  local key=$2;
  local res=/tmp/header_seq.$$$$

  ceph-kvstore-tool $omap_path get $prefix $key 2>/dev/null 1>$res
  if [ $? != 0 ]; then
    #echo "$func: <$prefix , $key> not exists" ;
    exit;
  fi

  # ceph-kvstore-tool get result like this:
  # 02 01 7e 00 00 00 12 44 00 00 00 00 00 00 00 00
  # get header seq bytes: 
  # 12 44 00 00 00 00 00 00 
  # -> 00 00 00 00 00 00 44 12 
  # echo $((16#0000000000004412)) -> 17426 == header_seq
  local seq=`cat $res |head -n 2|tail -n 1| \
  awk '
  BEGIN {
    FS=":"
    seq="";
    i=7;
  } {
    split($2, arr, " ")  
    # header_seq uint64 : 8 bytes
    for (x=7; x>=0; --x) {
      seq=seq""arr[i+x];
   }
  }
  END {
   print seq
  }'`
  if [ "$seq"x = ""x ];then
    #echo "$func: get <$prefix , $key> failed"
    exit;
  fi
  rm -f $res
  echo $((16#$seq))
}

# get header info key/value
function get_header_kv()
{
  local func="get_header_kv"
  if [ "$1"x = ""x ];then
    #echo "$func: no prefix input"
    exit
  elif [ "$2"x = ""x ];then
    #echo "$func: no key input"
    exit
  elif [ "$3"x != "string"x ] && [ "$3"x != "int"x ];then
    #echo "$func: no valid type input, use type (string|int)"
    exit
  fi

  local prefix=$1
  local key=$2
  local types=$3
  local res=/tmp/kv.$$$$

  ceph-kvstore-tool $omap_path get $prefix $key 2>/dev/null 1>$res
  if [ $? != 0 ];then
    #echo "$func: <$prefix , $key> not exists" 
    exit
  fi

  if [ "$types"x = "string"x ];then
    local value=`cat $res |tail -n +2|head -n -1|awk -F ": " '{printf $3}'|sed -n 's/^\.\{4\}//p'`
    echo $value
  elif [ "$types"x = "int"x ];then
    local value=`cat $res |tail -n +2|head -n -1| \
      awk '
        BEGIN{
          FS=":"
        } {
          split($2, arr, " ");
          len=length(arr)
          for (i=len; i>0; --i) { 
                printf arr[i];
          }
        }'`
    echo $((16#$value))
  fi
  rm -f $res
}
